name: Build, Push and Deploy (frontend + backend)

on:
  push:
    branches: [ "main" ]

env:
  SHORT_TAG: ${{ github.sha }}

  # Harbor registry/project (both images will live under REGISTRY/PROJECT)
  REGISTRY: docker-registry.ebrains.eu
  PROJECT: ebrains-data-curation

  # Kubernetes namespace (where Deployments exist)
  K8S_NAMESPACE: metadata-wizard-dev

  # Full image names (registry/project/repo)
  DEV_WIZARD_IMAGE: docker-registry.ebrains.eu/ebrains-data-curation/metadata-wizard-dev/image-wizard-dev
  
  # Container names inside the Deployments (must match k8s manifests)
  WIZARD_CONTAINER: container-dev-wizard

  # Kubernetes Deployment names (adjust to your real names)
  WIZARD_DEPLOYMENT: dev-wizard-deployment

jobs:
  build-push-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Debug TLS
        run: |
          curl -v https://docker-registry.ebrains.eu/v2/ 

      - name: Log in to Harbor
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.HARBOR_USERNAME }}
          password: ${{ secrets.HARBOR_PASSWORD }}

      - name: Build & push image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ env.DEV_WIZARD_IMAGE }}:${{ env.SHORT_TAG }}
            ${{ env.DEV_WIZARD_IMAGE }}:latest

      - name: Write kubeconfig (base64)
        env:
          KUBECONFIG_B64: ${{ secrets.KUBE_CONFIG }}
        run: |
          set -euo pipefail
          KUBE_DIR="${{ runner.temp }}/.kube"
          KUBE_FILE="${KUBE_DIR}/kubeconfig.yaml"
          mkdir -p "${KUBE_DIR}"

          # Decode the base64 secret into the kubeconfig file
          echo "${KUBECONFIG_B64}" | base64 --decode > "${KUBE_FILE}"

          # Sanity check: make sure it looks like a kubeconfig (contains apiVersion)
          if ! grep -q "apiVersion" "${KUBE_FILE}" ; then
            echo "Decoded file does not look like a kubeconfig; aborting"
            sed -n '1,200p' "${KUBE_FILE}" || true
            exit 1
          fi

          chmod 600 "${KUBE_FILE}"
          echo "Wrote kubeconfig to ${KUBE_FILE}"
          # optional preview for debugging (first 10 lines)
          sed -n '1,10p' "${KUBE_FILE}"

      - name: Verify cluster (optional)
        run: |
          set -euo pipefail
          KUBE_FILE="${{ runner.temp }}/.kube/kubeconfig.yaml"
          # Use explicit --kubeconfig so we don't depend on env var
          kubectl --kubeconfig="${KUBE_FILE}" cluster-info || true
          kubectl --kubeconfig="${KUBE_FILE}" get ns || true

      - name: Patch image
        run: |
          set -euo pipefail
          KUBE_FILE="${{ runner.temp }}/.kube/kubeconfig.yaml"
          kubectl --kubeconfig="${KUBE_FILE}" -n ${{ env.K8S_NAMESPACE }} set image \
            deployment/${{ env.WIZARD_DEPLOYMENT }} \
            ${{ env.WIZARD_CONTAINER }}=${{ env.DEV_WIZARD_IMAGE }}:${{ env.SHORT_TAG }} --record

      - name: Wait for rollout
        run: |
          set -euo pipefail
          KUBE_FILE="${{ runner.temp }}/.kube/kubeconfig.yaml"
          kubectl --kubeconfig="${KUBE_FILE}" -n ${{ env.K8S_NAMESPACE }} rollout status deployment/${{ env.WIZARD_DEPLOYMENT }} --timeout=180s

      - name: Cleanup kubeconfig
        if: always()
        run: |
          KUBE_FILE="${{ runner.temp }}/.kube/kubeconfig.yaml"
          shred -u "${KUBE_FILE}" || rm -f "${KUBE_FILE}"
