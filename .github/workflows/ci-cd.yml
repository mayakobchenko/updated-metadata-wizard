name: Build, Push and Deploy (frontend + backend)

on:
  push:
    branches: [ "main" ]

env:
  SHORT_TAG: ${{ github.sha }}

  # Harbor registry/project (both images will live under REGISTRY/PROJECT)
  REGISTRY: docker-registry.ebrains.eu
  PROJECT: ebrains-data-curation

  # Kubernetes namespace (where Deployments exist)
  K8S_NAMESPACE: metadata-wizard-dev

  # Full image names (registry/project/repo)
  FRONTEND_IMAGE: docker-registry.ebrains.eu/ebrains-data-curation/image-frontend
  BACKEND_IMAGE:  docker-registry.ebrains.eu/ebrains-data-curation/image-backend

  # Container names inside the Deployments (must match k8s manifests)
  FRONTEND_CONTAINER: container-frontend
  BACKEND_CONTAINER:  container-backend

  # Kubernetes Deployment names (adjust to your real names)
  FRONTEND_DEPLOYMENT: frontend-deployment
  BACKEND_DEPLOYMENT: backend-deployment

jobs:
  build-push-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Debug TLS
        run: |
          curl -v https://docker-registry.ebrains.eu/v2/ 
          
      - name: Log in to Harbor
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.HARBOR_USERNAME }}
          password: ${{ secrets.HARBOR_PASSWORD }}

      - name: Build & push frontend
        uses: docker/build-push-action@v5
        with:
          context: ./client
          file: ./client/Dockerfile
          push: true
          tags: |
            ${{ env.FRONTEND_IMAGE }}:${{ env.SHORT_TAG }}
            ${{ env.FRONTEND_IMAGE }}:latest

      - name: Build & push backend
        uses: docker/build-push-action@v5
        with:
          context: ./server
          file: ./server/Dockerfile
          push: true
          tags: |
            ${{ env.BACKEND_IMAGE }}:${{ env.SHORT_TAG }}
            ${{ env.BACKEND_IMAGE }}:latest

      - name: Write kubeconfig
        env:
          KUBECONFIG_CONTENT: ${{ secrets.KUBE_CONFIG }}
        run: |
          mkdir -p ${{ runner.temp }}/.kube
          echo "${KUBECONFIG_CONTENT}" > ${{ runner.temp }}/.kube/kubeconfig.yaml
          chmod 600 ${{ runner.temp }}/.kube/kubeconfig.yaml

      - name: Set KUBECONFIG
        run: echo "KUBECONFIG=${{ runner.temp }}/.kube/kubeconfig.yaml" >> $GITHUB_ENV

      - name: Verify cluster (optional)
        run: |
          kubectl cluster-info
          kubectl get ns || true

      - name: Patch backend image
        run: |
          kubectl -n ${{ env.K8S_NAMESPACE }} set image deployment/${{ env.BACKEND_DEPLOYMENT }} \
            ${{ env.BACKEND_CONTAINER }}=${{ env.BACKEND_IMAGE }}:${{ env.SHORT_TAG }} --record

      - name: Patch frontend image
        run: |
          kubectl -n ${{ env.K8S_NAMESPACE }} set image deployment/${{ env.FRONTEND_DEPLOYMENT }} \
            ${{ env.FRONTEND_CONTAINER }}=${{ env.FRONTEND_IMAGE }}:${{ env.SHORT_TAG }} --record

      - name: Wait for backend rollout
        run: |
          kubectl -n ${{ env.K8S_NAMESPACE }} rollout status deployment/${{ env.BACKEND_DEPLOYMENT }} --timeout=180s

      - name: Wait for frontend rollout
        run: |
          kubectl -n ${{ env.K8S_NAMESPACE }} rollout status deployment/${{ env.FRONTEND_DEPLOYMENT }} --timeout=180s

      - name: Cleanup kubeconfig
        if: always()
        run: |
          shred -u ${{ runner.temp }}/.kube/kubeconfig.yaml || rm -f ${{ runner.temp }}/.kube/kubeconfig.yaml
